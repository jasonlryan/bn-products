#!/usr/bin/env python3
"""
STAGE 1: CSV to Products Pipeline
Generates product content files from CSV data using AI prompts.

Usage:
  python3 01_csv_to_products.py --all                    # Process all products
  python3 01_csv_to_products.py --product 01_ai_power_hour  # Process specific product
  python3 01_csv_to_products.py --list                   # List available products
"""

import csv
import os
import re
import json
import time
import argparse
from pathlib import Path
from typing import Dict, List, Optional
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

try:
    from openai import OpenAI
    client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
    HAS_OPENAI = True
except ImportError:
    print("‚ö†Ô∏è  OpenAI package not installed. Install with: pip install openai")
    HAS_OPENAI = False

class CSVToProductsProcessor:
    def __init__(self, csv_path="../data/BN Products List   - 2025.csv", 
                 prompts_dir="../prompts", output_dir="../products"):
        self.csv_path = Path(csv_path)
        self.prompts_dir = Path(prompts_dir)
        self.output_dir = Path(output_dir)
        
        # Ensure output directory exists
        self.output_dir.mkdir(exist_ok=True)
        
        # Content type mapping - Optimized 14-prompt pipeline
        self.content_types = {
            # Executive & Product (4)
            "01_executive_positioning": "manifesto",
            "02_product_capabilities": "productCapabilities", 
            "03_functional_specification": "functionalSpec",
            "04_use_cases_scenarios": "userStories",
            
            # Market Intelligence (3)
            "05_audience_icps": "audienceICPs",
            "06_competitor_analysis": "competitorAnalysis",
            "07_market_sizing": "marketSizing",
            
            # Sales Enablement (4)
            "08_key_messages": "keyMessages",
            "09_demo_script": "demoScript",
            "10_presentation_structure": "slideHeadlines",
            "11_discovery_qualification": "discoveryQualification",
            
            # Strategic Planning (3)
            "12_qa_prep": "qaPrep",
            "13_pricing_roi": "pricingStrategy",
            "14_gtm_strategy": "gtmStrategy"
        }

    def clean_filename(self, text):
        """Convert text to a clean filename format"""
        text = re.sub(r'[^\w\s-]', '', text.lower())
        text = re.sub(r'[-\s]+', '_', text)
        return text.strip('_')

    def read_products_from_csv(self):
        """Read products from CSV file"""
        products = []
        with open(self.csv_path, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            for i, row in enumerate(reader, 1):
                if not row.get('NAME'):
                    continue
                    
                # Clean column names and values
                cleaned_row = {}
                for key, value in row.items():
                    if key is not None:  # Fix for None keys
                        clean_key = key.strip()
                        clean_value = value.strip() if value else ""
                        cleaned_row[clean_key] = clean_value
                
                # Generate product ID
                product_id = f"{i:02d}_{self.clean_filename(cleaned_row['NAME'])}"
                cleaned_row['PRODUCT_ID'] = product_id
                products.append(cleaned_row)
        
        return products

    def read_prompts(self):
        """Read all prompt files from prompts directory"""
        prompts = []
        prompt_files = sorted([f for f in os.listdir(self.prompts_dir) if f.endswith('.md')])
        
        for filename in prompt_files:
            filepath = self.prompts_dir / filename
            with open(filepath, 'r', encoding='utf-8') as file:
                content = file.read()
                
            # Extract prompt number and name
            match = re.match(r'(\d+)_(.+)\.md', filename)
            if match:
                prompt_number = int(match.group(1))
                prompt_name = match.group(2)
                
                # Extract the actual prompt from content
                kick_off_prompt = self.extract_prompt_from_content(content)
                
                prompts.append({
                    'number': prompt_number,
                    'name': prompt_name,
                    'filename': filename,
                    'content': content,
                    'prompt': kick_off_prompt
                })
        
        return prompts

    def extract_prompt_from_content(self, content):
        """Extract the kick-off prompt from markdown content"""
        lines = content.split('\n')
        for i, line in enumerate(lines):
            if 'Kick-Off Prompt:' in line:
                # Find the actual prompt (usually in quotes)
                for j in range(i+1, min(i+10, len(lines))):
                    if lines[j].strip().startswith('"') and lines[j].strip().endswith('"'):
                        return lines[j].strip()[1:-1]  # Remove quotes
        return ""

    def format_product_context(self, product):
        """Format product data for LLM context"""
        return f"""
PRODUCT CONTEXT:

**Product Name:** {product['NAME']}
**Type:** {product.get('Type', 'PRODUCT')}
**Price:** {product.get('PRICE', '')}
**Primary Deliverables:** {product.get('Primary Deliverables', '')}

**Description:**
{product.get('DESCRIPTION', '')}

**Perfect For:**
{product.get('PERFECT FOR:', '')}

**What Client is Buying:**
{product.get('WHAT THE CLIENT IS ACTUALLY BUYING', '')}

**Ideal Client:**
{product.get('IDEAL CLIENT', '')}

**Key Features:**
{product.get('KEY FEATURES', '')}

**Benefits:**
{product.get('BENEFITS', '')}
"""

    def call_llm(self, prompt, product_context, previous_outputs, model=None):
        """Call OpenAI API to generate content"""
        if not HAS_OPENAI or not client:
            return "[AI Content Generation Not Available - Install openai package and set OPENAI_API_KEY]"
        
        # Use model from environment variable if not specified
        if model is None:
            model = os.getenv('DEFAULT_OPENAI_MODEL', 'gpt-5-mini')
        
        try:
            full_prompt = f"{prompt}\n\n{product_context}"
            if previous_outputs:
                full_prompt += f"\n\nPREVIOUS OUTPUTS:\n{previous_outputs}"
            
            # Build parameters based on model capabilities
            create_params = {
                "model": model,
                "messages": [{"role": "user", "content": full_prompt}]
            }
            
            if model.startswith('gpt-5'):
                # GPT-5 models: use defaults (temperature=1, no explicit token limits)
                pass
            else:
                # Other models: can customize temperature and token limits
                create_params["temperature"] = 0.7
                create_params["max_tokens"] = 2000
                
            response = client.chat.completions.create(**create_params)
            
            return response.choices[0].message.content
            
        except Exception as e:
            return f"[Error generating content: {e}]"

    def generate_product_file(self, product, prompt, previous_outputs=""):
        """Generate a single product file"""
        product_context = self.format_product_context(product)
        llm_output = self.call_llm(prompt['prompt'], product_context, previous_outputs)
        
        # Create markdown file content
        content = f"""# {product['NAME']} ‚Ä¢ {prompt['name'].replace('_', ' ').title()}

**Generated using:** {prompt['filename']}
**Model:** {os.getenv('DEFAULT_OPENAI_MODEL', 'gpt-5-mini')}
**Date:** {time.strftime('%Y-%m-%d %H:%M:%S')}
**Product:** {product['NAME']} ({product.get('PRICE', 'Price TBD')})

---

## Original Prompt
{prompt['prompt']}

---

## Product Context

### **Product Details**
- **Type:** {product.get('Type', 'PRODUCT')}
- **Price:** {product.get('PRICE', 'Price TBD')}
- **Primary Deliverables:** {product.get('Primary Deliverables', '')}

### **Description**
{product.get('DESCRIPTION', '')}

### **Perfect For**
{product.get('PERFECT FOR:', '')}

### **What Client is Buying**
{product.get('WHAT THE CLIENT IS ACTUALLY BUYING', '')}

### **Ideal Client**
{product.get('IDEAL CLIENT', '')}

### **Key Features**
{product.get('KEY FEATURES', '')}

### **Benefits**
{product.get('BENEFITS', '')}

---

## Generated Output

{llm_output}

---

## Context Used
- Product data from CSV
{f"- Previous outputs: {len(previous_outputs.split('---')) if previous_outputs else 0} prior prompts" if previous_outputs else "- No previous outputs (first prompt)"}

**Generated on:** {time.strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        return content

    def process_product(self, product_id):
        """Process a specific product through all prompts"""
        print(f"\nüéØ Processing product: {product_id}")
        
        # Find the product in CSV
        products = self.read_products_from_csv()
        product = None
        for p in products:
            if p['PRODUCT_ID'] == product_id:
                product = p
                break
        
        if not product:
            print(f"‚ùå Product {product_id} not found in CSV")
            return False
        
        # Read prompts
        prompts = self.read_prompts()
        if not prompts:
            print("‚ùå No prompts found")
            return False
        
        print(f"üìù Found {len(prompts)} prompts")
        
        # Process each prompt for this product
        previous_outputs = ""
        generated_files = 0
        
        for prompt in prompts:
            print(f"   Processing prompt {prompt['number']:02d}: {prompt['name']}")
            
            # Generate content
            file_content = self.generate_product_file(product, prompt, previous_outputs)
            
            # Save file
            filename = f"{product_id}_{prompt['number']:02d}_{prompt['name']}.md"
            filepath = self.output_dir / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(file_content)
            
            generated_files += 1
            
            # Add to previous outputs for next prompt
            previous_outputs += f"--- {prompt['name']} ---\n{file_content}\n\n"
            
            # Small delay to avoid rate limits
            time.sleep(1)
        
        print(f"‚úÖ Generated {generated_files} files for {product_id}")
        return True

    def process_all_products(self):
        """Process all products in CSV"""
        products = self.read_products_from_csv()
        
        print(f"\nüöÄ Processing {len(products)} products from CSV")
        
        success_count = 0
        for product in products:
            if self.process_product(product['PRODUCT_ID']):
                success_count += 1
        
        print(f"\n‚úÖ Successfully processed {success_count}/{len(products)} products")
        return success_count == len(products)

    def list_products(self):
        """List all available products from CSV"""
        products = self.read_products_from_csv()
        
        print("\nüìã Available Products:")
        for i, product in enumerate(products, 1):
            print(f"   {i:2d}. {product['PRODUCT_ID']} - {product['NAME']} ({product.get('PRICE', 'Price TBD')})")
        
        print(f"\nTotal: {len(products)} products")
        return products

def main():
    parser = argparse.ArgumentParser(description='STAGE 1: Generate product content from CSV + prompts')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--all', action='store_true', help='Process all products')
    group.add_argument('--product', type=str, help='Process specific product (e.g., 01_ai_power_hour)')
    group.add_argument('--list', action='store_true', help='List available products')
    
    args = parser.parse_args()
    
    processor = CSVToProductsProcessor()
    
    try:
        if args.list:
            processor.list_products()
        elif args.all:
            processor.process_all_products()
        elif args.product:
            processor.process_product(args.product)
    
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())